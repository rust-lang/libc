/* This file was autogenerated by ctest; do not modify directly */

/// As this file is sometimes built using rustc, crate level attributes
/// are not allowed at the top-level, so we hack around this by keeping it
/// inside of a module.
mod generated_tests {
    #![allow(non_snake_case)]
    #![deny(improper_ctypes_definitions)]
    use std::fmt::{Debug, LowerHex};
    use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
    use std::{mem, ptr, slice};
    use std::mem::offset_of;

    use super::*;

    pub static FAILED: AtomicBool = AtomicBool::new(false);
    pub static NTESTS: AtomicUsize = AtomicUsize::new(0);

    /// Check that the value returned from the Rust and C side in a certain test is equivalent.
    ///
    /// Internally it will remember which checks failed and how many tests have been run.
    fn check_same<T: PartialEq + Debug>(rust: T, c: T, attr: &str) {
        if rust != c {
            eprintln!("bad {attr}: rust: {rust:?} != c {c:?}");
            FAILED.store(true, Ordering::Relaxed);
        } else {
            NTESTS.fetch_add(1, Ordering::Relaxed);
        }
    }

    /// Check that the value returned from the Rust and C side in a certain test is equivalent.
    ///
    /// Internally it will remember which checks failed and how many tests have been run. This
    /// method is the same as `check_same` but prints errors in bytes in hex.
    fn check_same_hex<T: PartialEq + LowerHex + Debug>(rust: T, c: T, attr: &str) {
        if rust != c {
            eprintln!("bad {attr}: rust: {rust:?} ({rust:#x}) != c {c:?} ({c:#x})");
            FAILED.store(true, Ordering::Relaxed);
        } else {
            NTESTS.fetch_add(1, Ordering::Relaxed);
        }
    }

    // Test that the value of the constant is the same in both Rust and C.
    // This performs a byte by byte comparision of the constant value.
    pub fn const_ON() {
        extern "C" {
            fn __test_const_ON() -> *const bool;
        }
        let val = ON;
        unsafe {
            let ptr1 = ptr::from_ref(&val).cast::<u8>();
            let ptr2 = __test_const_ON().cast::<u8>();
            let ptr1_bytes = slice::from_raw_parts(ptr1, mem::size_of::<bool>());
            let ptr2_bytes = slice::from_raw_parts(ptr2, mem::size_of::<bool>());
            for (i, (&b1, &b2)) in ptr1_bytes.iter().zip(ptr2_bytes.iter()).enumerate() {
                // HACK: This may read uninitialized data! We do this because
                // there isn't a good way to recursively iterate all fields.
                check_same_hex(b1, b2, &format!("ON value at byte {i}"));
            }
        }
    }

    /// Test that the size and alignment of the aliased type is the same in both Rust and C.
    /// 
    /// This can fail if a different type is used on one side, and uses the built in size and
    /// alignment functions to check.
    pub fn size_align_in6_addr() {
        extern "C" {
            fn __test_size_in6_addr() -> u64;
            fn __test_align_in6_addr() -> u64;
        }
        unsafe {
            check_same(mem::size_of::<in6_addr>() as u64,
                __test_size_in6_addr(), "in6_addr size");
            check_same(mem::align_of::<in6_addr>() as u64,
                __test_align_in6_addr(), "in6_addr align");
        }
    }

    /// Test that the aliased type has the same sign (signed or unsigned) in both Rust and C.
    ///
    /// This check can be performed because `!(0 as _)` yields either -1 or the maximum value
    /// depending on whether a signed or unsigned type is used. This is simply checked on both
    /// Rust and C sides to see if they are equal.
    pub fn sign_in6_addr() {
        extern "C" {
            fn __test_signed_in6_addr() -> u32;
        }
        unsafe {
            check_same(((!(0 as in6_addr)) < (0 as in6_addr)) as u32,
                    __test_signed_in6_addr(), "in6_addr signed");
        }
    }

    /// Generates a padding map for a specific type.
    ///
    /// Essentially, it returns a list of bytes, whose length is equal to the size of the type in
    /// bytes. Each element corresponds to a byte and has two values. `1` if the byte is padding,
    /// and `0` if the byte is not padding.
    ///
    /// For type aliases, the padding map is all zeroes.
    fn roundtrip_padding_in6_addr() -> Vec<u8> {
        vec![0; mem::size_of::<in6_addr>()]
    }

    /// Tests whether the type alias `x` when passed to C and back to Rust remains unchanged.
    ///
    /// It checks if the size is the same as well as if the padding bytes are all in the
    /// correct place.
    pub fn roundtrip_in6_addr() {
        use std::ffi::c_int;

        type U = in6_addr;
        extern "C" {
            fn __test_roundtrip_in6_addr(
                size: i32, x: U, e: *mut c_int, pad: *const u8
            ) -> U;
        }
        let pad = roundtrip_padding_in6_addr();
        unsafe {
            use std::mem::{MaybeUninit, size_of};
            let mut error: c_int = 0;
            let mut y = MaybeUninit::<U>::uninit();
            let mut x = MaybeUninit::<U>::uninit();
            let x_ptr = x.as_mut_ptr().cast::<u8>();
            let y_ptr = y.as_mut_ptr().cast::<u8>();
            let sz = size_of::<U>();
            for i in 0..sz {
                let c: u8 = (i % 256) as u8;
                let c = if c == 0 { 42 } else { c };
                let d: u8 = 255_u8 - (i % 256) as u8;
                let d = if d == 0 { 42 } else { d };
                x_ptr.add(i).write_volatile(c);
                y_ptr.add(i).write_volatile(d);
            }
            let r: U = __test_roundtrip_in6_addr(sz as i32, x.assume_init(), &mut error, pad.as_ptr());
            if error == 1 {
                FAILED.store(true, Ordering::Relaxed);
                return;
            }
            for (i, elem) in pad.iter().enumerate().take(size_of::<U>()) {
                if *elem == 1 { continue; }
                let rust = (*y_ptr.add(i)) as usize;
                let c = (&r as *const _ as *const u8)
                            .add(i).read_volatile() as usize;
                if rust != c {
                    eprintln!(
                        "rust [{i}] = {rust} != {c} (C): C \"in6_addr\" -> Rust",
                    );
                    FAILED.store(true, Ordering::Relaxed);
                }
            }
        }
    }
}

use generated_tests::*;

fn main() {
    println!("RUNNING ALL TESTS");
    run_all();
    if FAILED.load(std::sync::atomic::Ordering::Relaxed) {
        panic!("some tests failed");
    } else {
        println!(
            "PASSED {} tests",
            NTESTS.load(std::sync::atomic::Ordering::Relaxed)
        );
    }
}

// Run all tests by calling the functions that define them.
fn run_all() {
    const_ON();
    size_align_in6_addr();
    sign_in6_addr();
    roundtrip_in6_addr();
}
