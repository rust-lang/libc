name: CI

on:
  merge_group:
  pull_request:
    types: [opened, synchronize, reopened]
  schedule:
    # Run CI on `main` daily so there is a cache available for merge queues.
    # See <https://github.com/orgs/community/discussions/66430>
    - cron: "0 8 * * *"
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  CARGO_TERM_VERBOSE: true
  LIBC_CI: 1
  RUSTDOCFLAGS: -Dwarnings
  RUSTFLAGS: -Dwarnings
  RUST_BACKTRACE: full

defaults:
  run:
    shell: bash

jobs:
  test_tier1:
    name: Test tier1
    strategy:
      fail-fast: true
      matrix:
        id: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        target:
          - i686-pc-windows-msvc
          - x86_64-pc-windows-gnu
          - x86_64-pc-windows-msvc
    runs-on: ${{ contains(matrix.target, 'aarch') && 'windows-11-arm' || 'windows-2025' }}
    timeout-minutes: 25
    env:
      TARGET: ${{ matrix.target }}
    steps:
      - uses: actions/checkout@v5
      - name: Setup Rust toolchain
        run: ./ci/install-rust.sh
      - uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.target }}

      - name: Run natively
        run: ./ci/run.sh ${{ matrix.target }}

      - name: Create CI artifacts
        id: create_artifacts
        if: always()
        run: |
          set -xe
          echo "step is actually running"
          which python3 || true
          ls -l $(which python3) || true
          python3 -c 'print("I work")'
          python3 ci/create-artifacts.py
      - uses: actions/upload-artifact@v5
        if: always() && steps.create_artifacts.outcome == 'success'
        with:
          name: ${{ env.ARCHIVE_NAME }}-${{ matrix.target }}-${{ matrix.id }}${{ matrix.artifact-tag && format('-{0}', matrix.artifact-tag) }}
          path: ${{ env.ARCHIVE_PATH }}
          retention-days: 5


  # One job that "summarizes" the success state of this pipeline. This can then be added to branch
  # protection, rather than having to add each job separately.
  success:
    name: success
    runs-on: ubuntu-24.04
    needs:
      - test_tier1
    # GitHub branch protection is exceedingly silly and treats "jobs skipped because a dependency
    # failed" as success. So we have to do some contortions to ensure the job fails if any of its
    # dependencies fails.
    if: always() # make sure this is never "skipped"
    steps:
      # Manually check the status of all dependencies. `if: failure()` does not work.
      - name: check if any dependency failed
        run: jq --exit-status 'all(.result == "success")' <<< '${{ toJson(needs) }}'
